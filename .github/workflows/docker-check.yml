name: Docker Build Check

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy:
        description: "Run docker compose up -d (self-hosted)"
        required: false
        type: boolean
        default: false
      pull:
        description: "docker compose pull before build"
        required: false
        type: boolean
        default: false
      deploy_k8s:
        description: "Deploy to Minikube (K8s)"
        required: false
        type: boolean
        default: false

jobs:
  build-docker-images:
    runs-on: self-hosted
    timeout-minutes: 60
    env:
      DOCKER_HOST: unix:///run/docker.sock
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Disk usage (before)
      run: |
        echo "=== Disk usage before ==="
        df -h || true
        echo "=== Docker disk usage before ==="
        docker system df || true

    - name: Pre-clean Docker space
      run: |
        echo "Pruning unused Docker data before build..."
        docker container prune -f || true
        docker image prune -af || true
        docker builder prune -af || true

    - name: Docker diagnostics
      run: |
        echo "USER: $(whoami)"
        echo "ID: $(id)"
        docker --version || true
        docker compose version || docker-compose --version || true
        groups || true
        echo "Docker socket perms:"
        ls -l /var/run/docker.sock || ls -l /run/docker.sock || true
        echo "DOCKER_* env vars:"
        env | sort | grep -E '^DOCKER_' || true
        docker context ls || true
        docker info || true

    - name: Verify Docker connectivity
      run: |
        echo "Checking docker ps via $DOCKER_HOST"
        docker ps

    - name: Build Backend Image
      run: docker build -f DockerfileBuild -t demo-backend:test .

    - name: Build Frontend Image
      run: docker build -f DockerfileFrontend -t demo-frontend:test .

    - name: Optional docker compose pull
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.pull == true }}
      run: |
        echo "Pulling latest images (ignore failures for local builds)..."
        docker compose pull || true

    - name: Optional docker compose up (deploy on self-hosted)
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.deploy == true && startsWith(github.ref, 'refs/heads/main') }}
      env:
        COMPOSE_DOCKER_CLI_BUILD: 1
        DOCKER_BUILDKIT: 1
      run: |
        echo "Bringing up the stack in background..."
        docker compose build
        docker compose up -d
        echo "Compose status:"
        docker compose ps || true
        echo "Containers:"
        docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
        echo "Health check backend:"
        curl -fsS http://localhost:8080/api/health || true
        echo "Health check frontend (index):"
        curl -fsS http://localhost:3000/ || true

    - name: Auto-deploy disk check and cleanup
      if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main') }}
      run: |
        echo "=== Disk usage before auto-deploy ==="; df -h || true
        echo "=== Docker disk usage before ==="; docker system df || true
        FREE_MB=$(df -Pm / | awk 'NR==2 {print $4}'); echo "Free space: ${FREE_MB} MB"
        if [ "${FREE_MB}" -lt 5000 ]; then
          echo "Less than 5GB free. Pruning aggressively..."
          docker container prune -f || true
          docker image prune -af || true
          docker builder prune -af || true
          docker volume prune -f || true
          FREE_MB=$(df -Pm / | awk 'NR==2 {print $4}'); echo "Free after prune: ${FREE_MB} MB"
          if [ "${FREE_MB}" -lt 5000 ]; then
            echo "Still <5GB free. Switching to minimal profile (app only, no db).";
            echo "COMPOSE_PROFILES=app" >> $GITHUB_ENV
            echo "USE_IN_MEMORY_DB=true" >> $GITHUB_ENV
          else
            echo "Enough space after prune for full stack.";
            echo "COMPOSE_PROFILES=app,db" >> $GITHUB_ENV
            echo "USE_IN_MEMORY_DB=false" >> $GITHUB_ENV
          fi
        else
          echo "Sufficient space (>=5GB). Using full stack.";
          echo "COMPOSE_PROFILES=app,db" >> $GITHUB_ENV
          echo "USE_IN_MEMORY_DB=false" >> $GITHUB_ENV
        fi

    - name: Auto docker compose up on push to main
      if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main') }}
      env:
        COMPOSE_DOCKER_CLI_BUILD: 1
        DOCKER_BUILDKIT: 1
      run: |
        echo "Auto-deploy: bringing up stack due to push to main..."
        echo "Profiles: $COMPOSE_PROFILES"
        PROFILE_ARGS=""
        if [ -n "$COMPOSE_PROFILES" ]; then
          for p in $(echo $COMPOSE_PROFILES | tr ',' ' '); do
            PROFILE_ARGS="$PROFILE_ARGS --profile $p"
          done
        fi
        echo "Using compose args: $PROFILE_ARGS"
        echo "USE_IN_MEMORY_DB=$USE_IN_MEMORY_DB"
        docker compose $PROFILE_ARGS build
        docker compose $PROFILE_ARGS up -d
        docker compose ps || true
        docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'

    - name: Auto-deploy to Kubernetes on push to main
      if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main') }}
      run: |
        echo "=== Auto-deploying to Kubernetes ==="
        
        # Check if Minikube is installed and running
        if ! command -v minikube &> /dev/null; then
          echo "Minikube not installed, skipping K8s deployment"
          exit 0
        fi
        
        # Start Minikube if not running
        if ! minikube status | grep -q "Running"; then
          echo "Starting Minikube..."
          minikube start --driver=docker --cpus=2 --memory=4096
        fi
        
        # Use Minikube's Docker daemon
        eval $(minikube docker-env)
        
        # Build images in Minikube context (no cache to ensure fresh build)
        echo "Building images for Kubernetes..."
        docker build --no-cache -f DockerfileBuild -t devops-lab-backend:latest .
        docker build --no-cache -f DockerfileFrontend -t devops-lab-frontend:latest .
        
        # Apply Kubernetes manifests
        echo "Applying K8s manifests..."
        kubectl apply -f k8s/sqlserver-deployment.yaml
        kubectl apply -f k8s/backend-deployment.yaml
        kubectl apply -f k8s/frontend-deployment.yaml
        
        # Restart deployments to pick up new images
        kubectl rollout restart deployment/backend
        kubectl rollout restart deployment/frontend
        
        # Wait for deployments
        echo "Waiting for deployments..."
        kubectl wait --for=condition=available --timeout=300s deployment/backend || true
        kubectl wait --for=condition=available --timeout=300s deployment/frontend || true
        
        # Setup port forwarding
        echo "Setting up port forwarding..."
        pkill -f "port-forward.*frontend.*30080" || true
        nohup kubectl port-forward --address 0.0.0.0 svc/frontend 30080:80 > /tmp/k8s-port-forward.log 2>&1 &
        sleep 3
        
        # Show status
        echo "=== K8s Status ==="
        kubectl get pods
        kubectl get svc
        echo "=== Access ==="
        echo "Frontend: http://localhost:30080"
        echo "Minikube IP: $(minikube ip)"

    - name: Post-clean Docker space
      if: ${{ always() && !(github.event_name == 'workflow_dispatch' && inputs.deploy == true) && !(github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main')) }}
      run: |
        echo "Removing job images and pruning..."
        docker image rm -f demo-backend:test demo-frontend:test || true
        docker container prune -f || true
        docker image prune -af || true
        docker builder prune -af || true

    - name: Disk usage (after)
      if: always()
      run: |
        echo "=== Disk usage after ==="
        df -h || true
        echo "=== Docker disk usage after ==="
        docker system df || true